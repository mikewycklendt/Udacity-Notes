DOCUMENT OBJECT  MODEL

The DOM is standardized by the W3C. There are a number of specifications that make up the DOM, here are few:

Core Specification
Events Specification
Style Specification
Validation Specification
Load and Save Specification

The DOM is not:
part of the JavaScript language

The DOM is:
constructed from the browser
is globally accessible by JavaScript code using the document object

first: characters
second: tag
third: token
fourth: nodes
fifth: DOM

Node = Class
node = object

Properties(data)
	color of building
	number of doors
	number of windows
Methods(functionality)
	alarm system
	sprinkler system

Node = blueprint = Interface
node = real objects built from blueprint


NODE INTERFACE

Node (with a capital "N"!) is a blueprint that contains information about all of the properties and methods for real nodes (with a lowercase "n"!). If you're not used to them, the words "interface", "property", and "method" can be kind of cryptic at first. Just remember that:

	interface = blueprint
	properties = data
	methods = functionality

So the Node Interface is a blueprint for all of the properties (data) and methods (functionality) that every real node has after it's been created. Now, the Node Interface has a lot of properties and methods, but it's not very specific...I mean, what _is_ a node???

Just like "blueprint for a Building" is not as specific as "blueprint for a house" or "blueprint for a skyscraper". These are more-specific blueprints. And these more-specific blueprints would probably have their own properties and methods that are specific to just houses or just skyscrapers.



So the Node Interface is a blueprint for all of the properties (data) and methods (functionality) that every real node has after it's been created. Now, the Node Interface has a lot of properties and methods, but it's not very specific...I mean, what _is_ a node???

	document.body
	const bodyEI - document.body
	bodyEI.baseURI
	bodyEl.nodetype
		1 = Element


ELEMENT INTERFACE

Just like "blueprint for a Building" is not as specific as "blueprint for a house" or "blueprint for a skyscraper". These are more-specific blueprints. And these more-specific blueprints would probably have their own properties and methods that are specific to just houses or just skyscrapers.

EventTarget <-- Node <-- Element



Select An Element By ID
Let's take a look at how we can use JavaScript and the DOM to gain access to specific elements using their ID attribute.

Remember the document object from the previous section? Well, we're going to start using it! Remember the document object is an object, just like a JavaScript object. This means it has key/value pairs. Some of the values are just pieces of data, while others are functions (also known as methods!) that provide some type of functionality. The first DOM method that we'll be looking at is the .getElementById() method:

document.getElementById();
If we ran the code above in the console, we wouldn't get anything, because we did not tell it the ID of any element to get! We need to pass a string to .getElementById() of the ID of the element that we want it to find and subsequently return to us:

document.getElementById('footer');
One thing to notice right off the bat, is that we're passing 'footer', not '#footer'. It already knows that it's searching for an ID (its name _is_ "getElementById", for a reason!).

	$0 = Element selected in the elements pane
	$0.ClassName
	$0.hasAttribute('class');

	.outerHTML = Element Interface
	.id = Element Interface

	.textContent = Node Interface


Selecting Multiple Elements At Once
As I'm sure you remember from learning both HTML structure and CSS styling, an ID should be unique - meaning two or more elements should never have the same ID. Since IDs are unique, and since there will be only one element in the HTML with that ID, document.getElementById() will only ever return at most one element. So how would we select multiple DOM elements?

The next two DOM methods that we'll be looking at that both return multiple elements are:

.getElementsByClassName()
.getElementsByTagName()
Accessing Elements By Their Class
The first method we'll look at is .getElementsByClassName():

document.getElementsByClassName();
Similarly to .getElementById(), if we ran the code above in the console, we wouldn't get anything, because we did not tell it the class to search for! Also just like .getElementById(), .getElementsByClassName() is expecting that we call it with a string of the class we want it to search for/return:

document.getElementsByClassName('brand-color');

Beware of the S!
I know we haven't looked at .getElementsByTagName() just yet, but there's something different about .getElementById() compared with both .getElementsByClassName() and .getElementsByTagName() that I want to point out because it can be easy to miss; both .getElementsByClassName() and .getElementsByTagName() have an extra "s" in their name.

The method's name is .getElementsByClassName(), not .getElementByClassName(). Notice the word right in the middle, it's "Elements" not "Element". If you think about it, this actually makes a lot of sense! Since both .getElementsByClassName() and .getElementsByTagName() could return multiple items, their method names tell us that directly. Now compare this with .getElementById() that will only ever return at most one element. Its name has the singular "Element" in it.

I just wanted to point this out because I've been bitten by that missing "s" many-a-time when running code like:

We just saw that .getElementsByClassName() returns an array-like data structure of elements. But what exactly _is_ an element?

In the next section, we'll take the plunge and look at Elements and Nodes.

Selecting Multiple Elements At Once Recap
In this section, we learned two ways to select multiple DOM elements:

.getElementsByClassName()
.getElementsByTagName()
There are a few important things to keep in mind about these two methods:

both methods use the document object
both return multiple items
the list that's returned is not an array
// select all elements that have the class "accent-color"
document.getElementsByClassName('accent-color');

// select all "span" elements
document.getElementsByTagName('span');


Do you remember the .getElementsByClassName() method on the document object that we looked at previously? While reviewing the Element interface, you might've noticed that it also has a .getElementsByClassName() method! The Element Interface inherits from the Node Interface, not the Document Interface (yep, there's a Document Interface!). The Element Interface has its own .getElementsByClassName() that does the exact same thing as the one on the document object.

This means that you can use the document object to select an element, then you can call .getElementsByClassName() on that element to receive a list of elements with the class name that are descendents of that specific element!

// selects the DOM element with an ID of "sidebar"
const sidebarElement = document.getElementById('sidebar');

// searches within the "sidebar" element for any elements with a class of "sub-heading"
const subHeadingList = sidebarElement.getElementsByClassName('sub-heading');






The querySelector Method
We can use the .querySelector() method to select elements just like we do with CSS. We use the .querySelector() method and pass it a string that's just like a CSS selector:

// find and return the element with an ID of "header"
document.querySelector('#header');

// find and return the first element with the class "header"
document.querySelector('.header');

// find and return the first <header> element
document.querySelector('header');

.querySelector() Returns A Single Element ⚠️
I want to point out one potentially tricky thing - the .querySelector() method only returns one element. This makes sense if you use it to search for an element by ID. However, even though .getElementsByClassName() and .getElementsByTagName() both return a list of multiple elements, using .querySelector() with a class selector or a tag selector will still only return the first item it finds.


The querySelectorAll Method
The .querySelector() method returns only one element from the DOM (if it exists). However, there are definitely times when you will want to get a list of all elements with a certain class or all of one type of element (e.g. all <tr> tags). We can use the .querySelectorAll() method to do this!

// find and return a list of elements with the class "header"
document.querySelectorAll('.header');

// find and return a list of <header> elements
document.querySelectorAll('header');

const listOfElements = document.querySelectorAll('h2');
for(let i = 0; i < listOfElements.length; i++){
	console.log('i is ' + 1)
	console.log(listOfElements(i));
}


Recap
In this section, we took a brief look the history of browser support for standard DOM methods, the rise of the jQuery library, and how jQuery's success brought about new DOM methods. The new DOM methods we looked at are

.querySelector() - returns a single element
.querySelectorAll() - returns a list of elements
// find and return the element with an ID of "header"
document.querySelector('#header');

// find and return a list of elements with the class "header"
document.querySelectorAll('.header');
We also took a brief look that the list returned by .querySelectorAll() is a NodeList. We saw that it is possible to loop over a NodeList with either its .forEach() method, or the humble for loop:

const allHeaders = document.querySelectorAll('header');

for(let i = 0; i < allHeaders.length; i++){
    console.dir(allHeaders[i]);
}






An Element's Inner HTML
Every element inherits properties and methods from the Element Interface (remember this from the previous lesson!). This means that every element has an .innerHTML property. This property, as it's rightly named, represents the markup of the element's content. We can use this property to:

get an element's (and all of its descendants!) HTML content
set an element's HTML content

Let's store the first .card element in a variable for easy access:

const nanodegreeCard = document.querySelector('.card');
Now that we've stored the first card element in the nanodegreeCard variable, we can use nanodegreeCard to refer to this element instead of having to use document.querySelector('.card') to select the element every time we need access to it.




💡 Innie vs Outie 💡
The .innerHTML property sets or returns the HTML content inside the selected element (i.e. between the tags).

There's also the rarely used .outerHTML property. .outerHTML represents the HTML element itself, as well as its children.

<h1 id="pick-me">Greetings To <span>All</span>!</h1>

const innerResults = document.querySelector('#pick-me').innerHTML;
console.log(innerResults); // logs the string: "Greetings To <span>All</span>!"

const outerResults = document.querySelector('#pick-me').outerHTML;
console.log(outerResults); // logs the string: "<h1 id="pick-me">Greetings To <span>All</span>!</h1>"






An Element's Text Content
So .innerHTML will get/set an element's HTML content. If we just want the text content, we can use the fantastically named .textContent property!

The .textContent property will:

set the text content of an element and all its descendants
return the text content of an element and all its descendants
Let's check it out!

Check out the .textContent's documentation page on MDN: textContent docs

Setting an element's text content is easy, just set it like you would any other property:

nanodegreeCard.textContent = "I will be the updated text for the nanodegreeCard element!";

<h1 id="test">Ice Cream Flavors</h1>
Given the HTML above, what will be the .textContent value after running this code:

const myElement = document.querySelector('#test');
myElement.textContent = 'The <strong>Greatest</strong> Ice Cream Flavors';

		The	<strong>Greatest</strong> Ice Cream Flavors


We just saw that passing text that contains HTML characters to .textContent will not display the content as HTML. Instead, it will still display everything as text - even the HTML characters!

If you'd like to update an element, including its HTML, then you need to use the .innerHTML property:

myElement.textContent = 'The <strong>Greatest</strong> Ice Cream Flavors'; // doesn't work as expected

myElement.innerHTML = 'The <strong>Greatest</strong> Ice Cream Flavors';  // works as expected


n Element's Text Content - Version 2!
We can't close this section out without looking at the .innerText property!

Like the .textContent property, the .innerText property can be used to get/set an element's text content, but there are some important differences between the two properties.

.textContent sets/gets the text content of an element...pretty clear and simple.

.innerText, on the other hand, is a little tricker. Let's see this in action and then we'll discuss it!

As you saw, .innerText will get the visible text of the element. This is an important distinction! If CSS is used to hide any text inside that element, .innerText will not return that text, while .textContent will return it. And it's not just the hiding/showing nature of CSS that .innerText adheres to, .innerText will also honor changes to things like capitalization.

The .textContent property has been a standard for quite a long time. Conversely, .innerText property is a relatively new addition to the HTML specification. It has been around for a while but was not fully supported by all browser because it was not a part of the HTML specification.

Between .textContent and .innerText, you probably want to use .textContent since that will return all of the text no matter what. Rarely will you actually want only the visible text.






CREATE ELEMENT

As you've already discovered, the .createElement() method is a method on the document object:

// creates and returns a <span> element
document.createElement('span');

// creates and returns an <h3> element
document.createElement('h3');






APPEND CHILD

Adding Content To The Page
You may have noticed that using document.createElement() to create an element didn't actually add that newly created element anywhere on the page! Creating an element...just creates it. It doesn't add it to the DOM. Since the element isn't added to the DOM, it doesn't appear in the page (if you remember, the DOM is the parsed representation of the page). So, now that we can create brand new elements, we need to be able to add them to the DOM so that they'll show up on the page.

We can use the .appendChild() method to add an element to the page! Before we see how this element works, let's quickly define the word "append". There are several different definitions of the word, but I like the wording of the Cambridge Dictionary's the best:

to add something to the end of a piece of writing

definition of the word "append" (source)

Now, to use the .appendChild() method, it needs to be called on another element, not the document object!

// create a brand new <span> element
const newSpan = document.createElement('span');

// select the first (main) heading of the page
const mainHeading = document.querySelector('h1');

// add the the <span> element as the last child element of the main heading
mainHeading.appendChild(newSpan);


I like the Cambridge Dictionary's version because it clearly states how the content is added at the end. The .appendChild() method is called on one element, and is passed the element to append. The element that is about about to be appended is added as the last child. So, in the example above, the <span> element will appear in the DOM as a child of the <h1>...but it will appear at the end, after all text and any other elements that might be in the <h1>.


⚠️ .appendChild() Needs An Element! ⚠️
This is stated above, but I wanted to call this out, specifically. When you're using the .appendChild() method, it must be called on an existing element. To be clear, you can't call this on the document object, so the following will result in an error:

const newSpan = document.createElement('span');

// causes an error
document.appendChild(newSpan);


const newSpanContent = document.createElement('span');

newSpanElement.texContent = ', right now!'

const mainHeading = document.querySelector('h1');

mainHeading.appendChild(newSpanElement);




Creating Text Nodes
Just like you created new elements with the .createElement() method, you can also create new text nodes using the .createTextNode() method. Take a look at the following code that:

creates an paragraph element
creates a text node
appends the text node to the paragraph
appends the paragraph to the tag
const myPara = document.createElement('p');
const textOfParagraph = document.createTextNode('I am the text for the paragraph!');

myPara.appendChild(textOfParagraph);
document.body.appendChild(myPara);
However, since you already know about the .textContent property, the code below will provide the exact same result:

const myPara = document.createElement('p');

myPara.textContent = 'I am the text for the paragraph!';
document.body.appendChild(myPara);
Therefore, instead of creating a new text node and appending it to an element, it's faster and easier to just update the element's text with the .textContent property.

For more info, check out the documentation: createTextNode() docs

QUESTION 4 OF 4
What happens after running this code?

const mainHeading = document.querySelector('#main-heading');
const otherHeading = document.querySelector('#other-heading');
const excitedText = document.createElement('span');

excitedText.textContent = '!!!';
mainHeading.appendChild(excitedText);
otherHeading.appendChild(excitedText);
Don't guess it, test it! This one might surprise you!








CREATE TEXTNODE

<!DOCTYPE html>
<html lang="en">
<head>
<title>createTextNode example</title>
<script>
function addTextNode(text) {
  var newtext = document.createTextNode(text),
      p1 = document.getElementById("p1");

  p1.appendChild(newtext);
}
</script>
</head>

<body>
  <button onclick="addTextNode('YES! ');">YES!</button>
  <button onclick="addTextNode('NO! ');">NO!</button>
  <button onclick="addTextNode('WE CAN! ');">WE CAN!</button>

  <hr />

  <p id="p1">First line of paragraph.</p>
</body>
</html>


Just like you created new elements with the .createElement() method, you can also create new text nodes using the .createTextNode() method. Take a look at the following code that:

creates an paragraph element
creates a text node
appends the text node to the paragraph
appends the paragraph to the tag
const myPara = document.createElement('p');
const textOfParagraph = document.createTextNode('I am the text for the paragraph!');

myPara.appendChild(textOfParagraph);
document.body.appendChild(myPara);
However, since you already know about the .textContent property, the code below will provide the exact same result:

const myPara = document.createElement('p');

myPara.textContent = 'I am the text for the paragraph!';
document.body.appendChild(myPara);
Therefore, instead of creating a new text node and appending it to an element, it's faster and easier to just update the element's text with the .textContent property.


What happens after running this code?

const mainHeading = document.querySelector('#main-heading');
const otherHeading = document.querySelector('#other-heading');
const excitedText = document.createElement('span');

excitedText.textContent = '!!!';
mainHeading.appendChild(excitedText);
otherHeading.appendChild(excitedText);

		ONLY otherHeading has three exclamation marks

		The .appendChild() method will move an element from its current position to the new position.


INSERTING HTML IN OTHER LOCATIONS

By definition, the .appendChild() method will add an element as the last child of the parent element. It's impossible to put it as the first child or anywhere else...it has to be the last child. Wouldn't it be nice if there were a little flexibility in where we could add the child element?

Enter the .insertAdjacentHTML() method! The .insertAdjacentHTML() method has to be called with two arguments:

the location of the HTML
the HTML text that is going to be inserted
The first argument to this method will let us insert the new HTML in one of four different locations

beforebegin – inserts the HTML text as a previous sibling 
afterbegin – inserts the HTML text as the first child 
beforeend – inserts the HTML text as the last child 
afterend – inserts the HTML text as a following sibling

A visual example works best, and MDN's documentation has a fantastic example that I'll modify slightly:

<!-- beforebegin -->
<p>
    <!-- afterbegin -->
    Existing text/HTML content
    <!-- beforeend -->
</p>
<!-- afterend -->
Here's how we'd call .insertAdjacentHTML():

const mainHeading = document.querySelector('#main-heading');
const htmlTextToAdd = '<h2>Skydiving is fun!</h2>';

mainHeading.insertAdjacentHTML('afterend', htmlTextToAdd);



dd New Page Content Recap
In this section, we learned how to create new DOM elements and add them to the page. We looked at the following methods:

.createElement() to create new elements
.appendChild() to add a child element to a parent element as its last child
.createTextNode() to create a text node
.insertAdjacentHTML() to put HTML text anywhere around an element
Some important things to note are:

if an element already exists in the DOM and this element is passed to .appendChild(), the `.appendChild() method will move it rather than duplicating it
an element's .textContent property is used more often than creating a text node with the .createTextNode() method
the .insertAdjacentHTML() method's second argument has to be text, you can't pass an element









Removing a Child Element
We can use the .removeChild() method to...wait for it...remove a child element. Basically, this is exactly the opposite of the .appendChild() method. So just like the .appendChild() method, the .removeChild() method requires:

a parent element
the child element that will be removed
<parent-element>.removeChild(<child-to-remove>);

const.cardContainer = $0;

cardContainer.FirstChild
		#text

cardContainer.FirstElementChild
		<div class = 'hero__module---container'></div>


A drawback (and workaround!) with the .removeChild() Method
Just like the .appendChild() method, there's a (somewhat minor) drawback to the .removeChild() method. Both methods:

require access to parent to function
However, we don't actually need to have the parent element because there is a workaround! Just like the .firstElementChild property can be called on a parent element to access its first element, every element also has a parentElement property that refers to its parent! So if we have access to the child element that we're about to add or remove, you can use the parentElement property to "move focus" to the element's parent. Then we can call .removeChild() (or .appendChild()) on that referenced parent element.

Let's look at an example:

const mainHeading = document.querySelector('h1');

mainHeading.parentElement.removeChild(mainHeading);
Let's walk through this code.

const mainHeading = document.querySelector('h1');
The preceding code will select the first <h1> on the page and stores it in the mainHeading variable. Now to the next line:

mainHeading.parentElement.removeChild(mainHeading);
This starts with the mainHeading variable. It calls .parentElement, so the focus of the next code is directed at the parent element. Then .removeChild() is called on the parent element. Finally, mainHeading itself is passed as the element that needs to be removed from its parent.

So an element uses itself to remove itself from its parent. Pretty cool, huh?


Removing a Child Element (Part 2!)
We went through all of those steps selecting an element, using DOM traversal techniques like .parentElement and .firstElementChild, so that we can remove a child element. I showed you this way so that you can get some exposure and practice to moving around in the DOM.

Now, you might be glad (or frustrated! haha) to find out there's an easier way to do all this! We can move the child element directly with the .remove() method:

const mainHeading = document.querySelector('h1');

mainHeading.remove();


Remove Page Content Recap
In this short section, we learned two ways to remove an element from the page. You learned about:

.removeChild()
.remove()
The difference is that with .removeChild() must be called on the parent of the element being removed and must be passed the child to be removed, while .remove() can be called directly on the element to delete.

We also learned about the following helpful properties:

.firstChild
.firstElementChild
.parentElement
The difference between .firstChild and .firstElementChild, is that .firstElementChild will always return the first element, while .firstChild might return whitespace (if there is any) to preserve the formatting of the underlying HTML source code.










STYLE PAGE CONTENT
In this section, we'll be looking at controlling page and element styling using the following properties and methods:

.style.<prop>
.cssText()
.setAttribute()
.className
.classList


CSS Specificity
To be successful in this section, it will help to have an understanding of how CSS Specificity works. According to the MDN, "specificity" is:

the means by which browsers decide which CSS property values are the most relevant to an element and, therefore, will be applied.

Basically, the closer the style rule is to an element, the more specific it is. For example, a rule in a style attribute on an element will override a style rule for that element in a CSS stylesheet. There is also the specificity of the type of selector being used. An _ID_ is more specific than a class.



Modifying an Element's Style Attribute
Let's jump back to your knowledge of CSS. When trying to style an element, the most-specific rules that you can write for an element are written in that element's style attribute. Lucky for us, we can access access an element's style attribute using the .style property!

const mainHeading = document.querySelector('h1');

mainHeading.style.color = 'red';
Now, I want to point out that when using the .style property, you can only modify one CSS style at a time. That's why the previous code has .style.color = 'red' and not just .style = 'red'.


const heading = $0;

heading.style.color = 'orange';
heading.style.fontSize = '2em';




Adding Multiple Styles At Once
We've seen how the .style.<property> syntax will let us change just one piece of styling for an element. So if we wanted to set an element's color, background color, and font size, we'd have to use three separate lines of code:

const mainHeading = document.querySelector('h1');

mainHeading.style.color = 'blue';
mainHeading.style.backgroundColor = 'orange';
mainHeading.style.fontSize = '3.5em';
...and that's just for setting three styles. Imagine if we needed 15 or 20 different styles! So the .style.property syntax is perfect for setting one style at a time, but it's not great for controlling multiple styles.

Fortunately, we can use the .style.cssText property to set multiple CSS styles at once!

const mainHeading = document.querySelector('h1');

mainHeading.style.cssText = 'color: blue; background-color: orange; font-size: 3.5em';
Notice that when using the .style.cssText property, you write the CSS styles just as you would in a stylesheet; so you write font-size rather than fontSize. This is different than using the individual .style.<property> way.



Setting An Element's Attributes
Another way to set styles for an element is to bypass the .style.<property> and .style.cssText properties altogether and use the .setAttribute() method:

const mainHeading = document.querySelector('h1');

mainHeading.setAttribute('style', 'color: blue; background-color: orange; font-size: 3.5em;');


.setAttribute() Is Not Just For Styling
The setAttribute() method is not just for styling page elements. You can use this method to set any attribute for an element. If you want to give an element an ID, you can do that!:

const mainHeading = document.querySelector('h1');

// add an ID to the heading's sibling element
mainHeading.nextElementSibling.setAttribute('id', 'heading-sibling');

// use the newly added ID to access that element
document.querySelector('#heading-sibling').style.backgroundColor = 'red';
The last two lines could've been combined into one to bypass setting an ID and just styling the elment directly:

mainHeading.nextElementSibling.style.backgroundColor = 'red';
...but this was just to demonstrate that it's possible to set an attribute with JavaScript that affects the DOM which then can be used immediately




Accessing an Element's Classes
The first element property we'll look at is the .className property. This property returns a string of all of the element's classes. If an element has the following HTML:

<h1 id="main-heading" class="ank-student jpk-modal">Learn Web Development at Udacity</h1>
We could use .className to access the list of classes:

const mainHeading = document.querySelector('#main-heading');

// store the list of classes in a variable
const listOfClasses = mainHeading.className;

// logs out the string "ank-student jpk-modal"
console.log(listOfClasses);
The .className property returns a space-separated string of the classes. This isn't the most ideal format, unfortunately. We can, however, convert this space-separated string into an array using the JavaScript string method, .split():

const arrayOfClasses = listOfClasses.split(' ');

// logs out the array of strings ["ank-student", "jpk-modal"]
console.log(arrayOfClasses);
Now that we have an array of classes, we can do any data-intensive calculations:

use a for loop to loop through the list of class names
use .push() to add an item to the list
use .pop() to remove an item from the list
.className is a property, so we can set its value just by assigning a string to the property:

mainHeading.className = "im-the-new-class";
The above code erases any classes that were originally in the element's class attribute and replaces it with the single class im-the-new-class.

Since .className returns a string, it makes it hard to add or remove individual classes. As I mentioned earlier, we can convert the string to an array and then use different Array Methods to search for a class remove it from the list, and then update the .className with the remaining classes. However, we don't want to do all of that work! Let's use the newer .classList property.



The .classList Property
The .classList property is newer than the .className property, but is much nicer, check it out:

<h1 id="main-heading" class="ank-student jpk-modal">Learn Web Development at Udacity</h1>
const mainHeading = document.querySelector('#main-heading');

// store the list of classes in a variable
const listOfClasses = mainHeading.classList;

// logs out ["ank-student", "jpk-modal"]
console.log(listOfClasses);

The .classList property has a number of properties of its own. Some of the most popularly used ones are:

.add() - to add a class to the list
.remove() - to remove a class from the list
.toggle() - to add the class if it doesn't exists or remove it from the list if it does already exist
.contains() - returns returns a boolean based on if the class exists in the list or not


Style Page Content Recap
We learned a ton of content in this section! We looked at:

modifying individual styles with .style.<prop>
updating multiple styles at once with .style.cssText
getting/setting a list of classes with .className
getting/setting/toggling CSS classes with .classList
My recommendation to you is that, out of the list of techniques you learned in this section, to use the .classList property more than any other. .classList is by far the most helpful property of the bunch, and it helps to keep your CSS styling out of your JavaScript code.















BROWSER EVENTS


The monitorEvents function will keep spitting out all of the events that are happening on the targeted element until the end of time...that, or until you refresh the page. Alternatively, the Chrome browser does offer an unmonitorEvents() function that will turn off the announcing of events for the targeted element:

// start displaying all events on the document object
monitorEvents(document);

// turn off the displaying of all events on the document object.
unmonitorEvents(document);

One last little bit of info on monitorEvents is that this is for development/testing purposes only. It's not supposed to be used for production code.






An Event Target
Do you remember the Node Interface and the Element interface from the first lesson? Do you remember how the Element Interface is a descendant of the Node Interface, and therefore inherits all of Node's properties and methods?

Well there was one piece that I totally skipped over then but am addressing now. The Node Interface inherits from the EventTarget Interface.

A diagram showing EventTarget inherited by all nodes and elements
The EventTarget Interface is inherited by all nodes and elements.

The EventTarget page says that EventTarget:

is an interface implemented by objects that can receive events and may have listeners for them.

and

Element, document, and window are the most common event targets, but other objects can be event targets too…

As you can see from the image above, the EventTarget is at the top of the chain. This means that it does not inherit any properties or methods from any other interfaces. However, every other interface inherits from it and therefore contain its properties and methods. This means that each of the following is an "event target";

the document object
a paragraph element
a video element
etc.
I want to drive home that both the document object and any DOM element can be an event target. And again, why is this?...because both the Element Interface and the Document Interface inherit from the EventTarget Interface. So any individual element inherits from the Element Interface, which in turn inherits from the EventTarget Interface. Likewise, the document object comes from the Document Interface, which in turn inherits from the EventTarget Interface.

If you take a look at the EventTarget Interface, you'll notice that it doesn't have any properties and only three methods! These methods are:

.addEventListener()
.removeEventListener()
.dispatchEvent()
The one that we'll be looking at for the rest of this course will be the .addEventListener() method.






Adding An Event Listener
We've taken a brief look at this hidden world of events. Using the .addEventListener() method will let us listen for events and respond to them! I just said "listen for events". There are several ways to "phrase" this, so I want to give some examples:

listen for an event
listen to an event
hook into an event
respond to an event
...all of these mean the same thing and are interchangeable with one another.

Let's use some pseudo-code to explain how to set an event listener:

<event-target>.addEventListener(<event-to-listen-for>, <function-to-run-when-an-event-happens>);
So an event listener needs three things:

an event target - this is called the target
the type of event to listen for - this is called the type
a function to run when the event occurs - this is called the listener
The <event-target> (i.e. the target) goes right back to what we just looked at: everything on the web is an event target (e.g. the document object, a <p> element, etc.).

The <event-to-listen-for> (i.e. the type) is the event we want to respond to. It could be a click, a double click, the pressing of a key on the keyboard, the scrolling of the mouse wheel, the submitting of a form...the list goes on!

The <function-to-run-when-an-event-happens> (i.e. the listener) is a function to run when the event actually occurs.

Let's transform the pseudo-code to a real example of an event listener:

const mainHeading = document.querySelector('h1');

mainHeading.addEventListener('click', function () {
  console.log('The heading was clicked!');
});
Let's break down the snippet above:

the target is the first <h1> element on the page
the event type to listen for is a "click" event
the listener is a function that logs "The heading was clicked!" to the console


In the following code, what is the event type?

const lotsOfElements = document.querySelectorAll('.quizzing-quizzby');
const element = lotsOfElements[2];

element.addEventListener('animationend', function () {
    const mainHeading = document.querySelector('h1');

    mainHeading.style.backgroundColor = 'purple'; 
});

		The string animationend

document.addEventListener('click', function() {
	const mainHeading = document.querySelector('h1');

	mainHeading.style.backgroundColor = 'red';
})







Removing An Event Listener
We say that we can use an event target's .addEventListener() method to start listening for specific events and respond to them. Let's say you only want to listen for just the first click event, respond to it, and ignore all other click events. The .addEventListener() event will listen for and respond to all click events.

(The newest version of the .addEventListener() specification does allow for an object to be passed as a third parameter. This object can be used to configure how the .addEventListener() method behaves. Of note, there is an option to listen for only a single event. However, this configuration object is not widely supported just yet).

To remove an event listener, we use the .removeEventListener() method. It sounds straightforward enough, right? However, before we look at .removeEventListener(), we need to take a brief review of object equality. It seems like an odd jump, but it'll make sense in just a moment.

Are Objects Equal in JavaScript
Equality is a common task in most programming languages, but in JavaScript, it can be a little bit tricky because JavaScript does this thing called type coercion where it will try to convert the items being compared into the same type. (e.g. string, number,). JavaScript has the double equality (==) operator that will allow type coercion. It also has the triple equality (===) symbol that will prevent type coercion when comparing.

Hopefully, this is all review. But let's talk about just object equality, which includes objects, arrays, and functions. Try giving this quiz a shot:

QUESTION 1 OF 4
Will the following equality test result in true or false?

{ name: 'Richard' } === { name: 'Richard' }
		false


Ok, so why do we care about any of this object/function equality? The reason is that the .removeEventListener() method requires you to pass the same exact listener function to it as the one you passed to .addEventListener().

Let's see some pseudo-code for the .removeEventListener():

<event-target>.removeEventListener(<event-to-listen-for>, <function-to-remove>);
So an event listener needs three things:

an event target - this is called the target
the type of event to listen for - this is called the type
the function to remove - this is called the listener
Remember, the listener function must be the exact same function as the one used in the .addEventListener() call...not just an identical looking function. Let's look at a couple of examples.

This code will successfully add and then remove an event listener:

function myEventListeningFunction() {
    console.log('howdy');
}

// adds a listener for clicks, to run the `myEventListeningFunction` function
document.addEventListener('click', myEventListeningFunction);

// immediately removes the click listener that should run the `myEventListeningFunction` function
document.removeEventListener('click', myEventListeningFunction);
Now, why does this work? It works because both .addEventListener() and .removeEventListener:

have the same target
have the same type
and pass the exact same listener
Now let's look at an example that would not work (it does not remove the event listener):

// adds a listener for clicks, to run the `myEventListeningFunction` function
document.addEventListener('click', function myEventListeningFunction() {
    console.log('howdy');
});

// immediately removes the click listener that should run the `myEventListeningFunction` function
document.removeEventListener('click', function myEventListeningFunction() {
    console.log('howdy');
});
This code does not successfully remove the event listener. Again, why does this not work?

both .addEventListener() and .removeEventListener have the same target
both .addEventListener() and .removeEventListener have the same type
.addEventListener() and .removeEventListener have their own distinct listener functions...they do not refer to the exact same function (this is the reason the event listener removal fails!)

